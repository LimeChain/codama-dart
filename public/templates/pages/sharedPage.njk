/// This code was AUTOGENERATED using the codama library.
/// Please DO NOT EDIT THIS FILE, instead use visitors
/// to add features, then rerun codama to update it.
///
/// https://github.com/codama-idl/codama
///

// Shared utilities and types for the SDK.

import 'dart:convert';
import 'dart:typed_data';

import 'package:solana/solana.dart';

/// Account not found error.
class AccountNotFoundError extends Error {
  /// The address of the account that was not found.
  final Ed25519HDPublicKey address;

  /// Creates a new AccountNotFoundError.
  AccountNotFoundError(this.address);

  @override
  String toString() => 'Account not found: $address';
}

/// Binary reader for decoding Borsh-encoded data.
class BinaryReader {
  final ByteData
      _data; // holds the raw binary data buffer, that i read from. Represents entire sequence of bytes.

  // Offset tracks the current byte position in the buffer; advance it after each read to ensure correct sequential decoding.
  int _offset = 0;

  /// Creates a new BinaryReader.
  BinaryReader(this._data);

  Uint8List readDiscriminator() {
    final length = 8; // Discriminator is always the first 8 bytes
    final bytes =
        Uint8List.view(_data.buffer, _data.offsetInBytes + _offset, length);
    _offset += length;
    return bytes;
  }

  /// Reads a single public key (32 raw bytes, no prefix).
  Uint8List readPubkey() {
    final length = 32;
    final bytes = Uint8List.view(_data.buffer, _data.offsetInBytes + _offset, length);
    _offset += length;
    return bytes;
  }

  /// Reads a boolean value.
  bool readBool() {
    final value = _data.getUint8(_offset) != 0;
    _offset += 1;
    return value;
  }

  /// Reads a int data type.
  int readInt() {
    final b0 = _data.getUint8(_offset);
    final b1 = _data.getUint8(_offset + 1);
    final b2 = _data.getUint8(_offset + 2);
    final b3 = _data.getUint8(_offset + 3);
    _offset += 4;
    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
  }

  BigInt readBigInt() {
    BigInt result = BigInt.zero;
    for (int i = 0; i < 16; i++) {
      result |= BigInt.from(_data.getUint8(_offset + i)) << (8 * i);
    }
    _offset += 16;
    return result;
  }

  /// Reads an unsigned 8-bit integer.
  int readU8() {
    final value = _data.getUint8(_offset);
    _offset += 1;
    return value;
  }

  /// Reads an unsigned 16-bit integer.
  int readU16() {
    final value = _data.getUint16(_offset, Endian.little);
    _offset += 2;
    return value;
  }

  /// Reads an unsigned 32-bit integer.
  int readU32() {
    final value = _data.getUint32(_offset, Endian.little);
    _offset += 4;
    return value;
  }

  /// Reads an unsigned 64-bit integer.
  BigInt readU64() {
    final low = _data.getUint32(_offset, Endian.little);
    final high = _data.getUint32(_offset + 4, Endian.little);
    _offset += 8;
    return (BigInt.from(high) << 32) | BigInt.from(low);
  }

  /// Reads a signed 8-bit integer.
  int readI8() {
    final value = _data.getInt8(_offset);
    _offset += 1;
    return value;
  }

  /// Reads a signed 16-bit integer.
  int readI16() {
    final value = _data.getInt16(_offset, Endian.little);
    _offset += 2;
    return value;
  }

  /// Reads a signed 32-bit integer.
  int readI32() {
    final value = _data.getInt32(_offset, Endian.little);
    _offset += 4;
    return value;
  }

  /// Reads a signed 64-bit integer.
  BigInt readI64() {
    final low = _data.getUint32(_offset, Endian.little);
    final high = _data.getInt32(_offset + 4, Endian.little);
    _offset += 8;
    return (BigInt.from(high) << 32) | BigInt.from(low);
  }

  /// Reads a string.
  String readString() {
    final length = readU32();
    final bytes =
        Uint8List.view(_data.buffer, _data.offsetInBytes + _offset, length);
    _offset += length;
    return utf8.decode(bytes);
  }

  /// Reads a u8 array from Borsh data. If `length` is null, reads the length from a 4-byte prefix.
  Uint8List readU8Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Uint8List>(
      1,
      length,
      Uint8List.view,
      1,
      (offset) => _data.getUint8(offset),
    );
  }

  /// Reads a fixed-size i8 array of bytes.
  Int8List readI8Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Int8List>(
      1,
      length,
      Int8List.view,
      1,
      (offset) => _data.getInt8(offset),
    );
  }

  /// Reads a fixed-size u16 array of bytes.
  Uint16List readU16Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Uint16List>(
      2,
      length,
      Uint16List.view,
      2,
      (offset) => _data.getUint16(offset, Endian.little),
    );
  }

  /// Reads a fixed-size i16 array of bytes.
  Int16List readI16Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Int16List>(
      2,
      length,
      Int16List.view,
      2,
      (offset) => _data.getInt16(offset, Endian.little),
    );
  }

  /// Reads a fixed-size u32 array of bytes.
  Uint32List readU32Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Uint32List>(
      4,
      length,
      Uint32List.view,
      4,
      (offset) => _data.getUint32(offset, Endian.little),
    );
  }

  /// Reads a fixed-size i32 array of bytes.
  Int32List readI32Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Int32List>(
      4,
      length,
      Int32List.view,
      4,
      (offset) => _data.getInt32(offset, Endian.little),
    );
  }

  /// Reads a fixed-size u64 array of bytes.
  Uint64List readU64Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Uint64List>(
      8,
      length,
      Uint64List.view,
      8,
      (offset) => _data.getUint64(offset, Endian.little),
    );
  }

  /// Reads a fixed-size i64 array of bytes.
  Int64List readI64Array([int? length]) {
    if (length == null) {
      // Read the 4-byte little-endian length prefix (Borsh Vec)
      length = _data.getUint32(_offset, Endian.little);
      _offset += 4;
    }

    return readAlignedArray<Int64List>(
      8,
      length,
      Int64List.view,
      8,
      (offset) => _data.getInt64(offset, Endian.little),
    );
  }

  /// Reads a variable-length array of generic items.
  List<T> readArray<T>(T Function() itemReader) {
    final count = readU32();
    final result = <T>[];
    for (var i = 0; i < count; i++) {
      result.add(itemReader());
    }
    return result;
  }

  /// Reads a variable-length array of bytes.
  Uint8List readBytes() {
    final length = readU32();
    return readU8Array(length);
  }

  // ========= Utils for alignment-safe array reading ========

  // This function handles the problem of buffer's offset that is not properly aligned for typed array views.
  // It happens because i have fixed-size and prefixed-size arrays.
  T readAlignedArray<T>(
    int alignment,
    int length,
    T Function(ByteBuffer buffer, int offset, int length) viewConstructor,
    int bytesPerElement,
    int Function(int offset) manualGetter,
  ) {
    // Check the offset alignment for `Uint*List.view` it should be multiple of element size
    if ((_data.offsetInBytes + _offset) % alignment == 0) {
      final arr =
          viewConstructor(_data.buffer, _data.offsetInBytes + _offset, length);
      _offset += length * bytesPerElement;
      return arr;
    } else {
      // Manual read if not aligned
      // For example, for Uint16List:
      final arr = List.generate(length, (i) {
        final value = manualGetter(_offset);
        _offset += bytesPerElement;
        return value;
      });
      // Convert to typed list
      if (T == Uint8List) return Uint8List.fromList(arr) as T;
      if (T == Uint16List) return Uint16List.fromList(arr) as T;
      if (T == Uint32List) return Uint32List.fromList(arr) as T;
      if (T == Uint64List) return Uint64List.fromList(arr) as T;
      if (T == Int8List) return Int8List.fromList(arr) as T;
      if (T == Int16List) return Int16List.fromList(arr) as T;
      if (T == Int32List) return Int32List.fromList(arr) as T;
      if (T == Int64List) return Int64List.fromList(arr) as T;
      // ...add more types as needed
      return arr as T;
    }
  }
}

/// Binary writer for encoding Borsh data.
class BinaryWriter {
  final List<int> _bytes = [];

  void writeDiscriminator(Uint8List discriminator) {
    if (discriminator.length != 8) {
      throw ArgumentError('Discriminator must be exactly 8 bytes');
    }
    _bytes.addAll(discriminator);
  }

  /// Writes a boolean value.
  void writeBool(bool value) {
    _bytes.add(value ? 1 : 0);
  }

  void writeInt(int value) {
    _bytes.addAll([
      value & 0xFF,
      (value >> 8) & 0xFF,
      (value >> 16) & 0xFF,
      (value >> 24) & 0xFF,
    ]);
  }

  void writeBigInt(BigInt value) {
    for (int i = 0; i < 16; i++) {
      _bytes.add(((value >> (8 * i)) & BigInt.from(0xFF)).toInt());
    }
  }

  /// Writes an unsigned 8-bit integer.
  void writeU8(int value) {
    _bytes.add(value & 0xFF);
  }

  /// Writes an unsigned 16-bit integer.
  void writeU16(int value) {
    _bytes.addAll([
      value & 0xFF,
      (value >> 8) & 0xFF,
    ]);
  }

  /// Writes an unsigned 32-bit integer.
  void writeU32(int value) {
    _bytes.addAll([
      value & 0xFF,
      (value >> 8) & 0xFF,
      (value >> 16) & 0xFF,
      (value >> 24) & 0xFF,
    ]);
  }

  /// Writes an unsigned 64-bit integer.
  void writeU64(BigInt value) {
    final low = value & BigInt.from(0xFFFFFFFF);
    final high = (value >> 32) & BigInt.from(0xFFFFFFFF);

    _bytes.addAll([
      low.toInt() & 0xFF,
      (low.toInt() >> 8) & 0xFF,
      (low.toInt() >> 16) & 0xFF,
      (low.toInt() >> 24) & 0xFF,
      high.toInt() & 0xFF,
      (high.toInt() >> 8) & 0xFF,
      (high.toInt() >> 16) & 0xFF,
      (high.toInt() >> 24) & 0xFF,
    ]);
  }

  /// Writes a signed 8-bit integer.
  void writeI8(int value) {
    writeU8(value & 0xFF);
  }

  /// Writes a signed 16-bit integer.
  void writeI16(int value) {
    writeU16(value & 0xFFFF);
  }

  /// Writes a signed 32-bit integer.
  void writeI32(int value) {
    writeU32(value & 0xFFFFFFFF);
  }

  /// Writes a signed 64-bit integer.
  void writeI64(BigInt value) {
    writeU64(value & (BigInt.one << 64) - BigInt.one);
  }

  /// Writes a string.
  void writeString(String value) {
    final bytes = utf8.encode(value);
    writeU32(bytes.length);
    _bytes.addAll(bytes);
  }

  /// Writes a fixed-size and prefixed-size u8 array of bytes.
  void writeU8Array(Uint8List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeU8(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeU8(value[i]);
      }
    }
  }

  /// Writes a fixed-size and prefixed-size u8 array of bytes.
  void writeI8Array(Int8List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeI8(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeI8(value[i]);
      }
    }
  }

  /// Writes a fixed-size and prefixed-size u16 array of bytes.
  void writeU16Array(Uint16List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeU16(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeU16(value[i]);
      }
    }
  }

  /// Writes a fixed-size and prefixed-size i16 array of bytes.
  void writeI16Array(Int16List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeI16(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeI16(value[i]);
      }
    }
  }

  /// Writes a fixed-size and prefixed-size i16 array of bytes.
  void writeU32Array(Uint32List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeU32(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeU32(value[i]);
      }
    }
  }

  /// Writes a fixed-size i32 array of bytes.
  void writeI32Array(Int32List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeI32(v);
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeI32(value[i]);
      }
    }
  }

  /// Writes a fixed-size u64 array of bytes.
  void writeU64Array(Uint64List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeU64(BigInt.from(v));
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeU64(BigInt.from(value[i]));
      }
    }
  }

  /// Writes a fixed-size i64 array of bytes.
  void writeI64Array(Int64List value, int? length) {
    if (length == null) {
      // Variable-length: write length prefix
      writeU32(value.length);
      for (final v in value) {
        writeI64(BigInt.from(v));
      }
    } else {
      // Fixed-size: write exactly [length] elements, no prefix
      for (int i = 0; i < length; i++) {
        writeI64(BigInt.from(value[i]));
      }
    }
  }

  /// Writes a variable-length array of bytes.
  void writeBytes(Uint8List value) {
    writeU32(value.length);
    _bytes.addAll(value);
  }

  /// Writes a variable-length array of generic items.
  void writeArray<T>(List<T> items, void Function(T) itemWriter) {
    writeU32(items.length);
    for (final item in items) {
      itemWriter(item);
    }
  }

  /// Writes a single public key (32 raw bytes, no prefix).
  void writePubkey(Uint8List pubkeyBytes) {
    _bytes.addAll(pubkeyBytes);
  }

  /// Returns the byte array.
  Uint8List toBytes() => Uint8List.fromList(_bytes);
}
