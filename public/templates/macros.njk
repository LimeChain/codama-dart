{# Write a Dart documentation comment from an array of strings. #}
{% macro docblock(docs) %}
  {% for doc in docs %}
/// {{ doc }}
  {% endfor %}
{% endmacro %}

{# Generate a Dart class property with documentation #}
{% macro property(type, name, doc, nullable = false) %}
  {% if doc %}{{ docblock([doc]) }}
  {% endif %}
  {{ type }}
  {% if nullable %}?{% endif %}
  {{ name }};
{% endmacro %}

{# Generate a Dart final class property with documentation #}
{% macro finalProperty(type, name, doc, nullable = false) %}
  {% if doc %}{{ docblock([doc]) }}
  {% endif %}
  final {{ type }}
  {% if nullable %}?{% endif %}
  {{ name }};
{% endmacro %}

{# Default constructor for a Dart class with required fields #}
{% macro defaultConstructor(className, fields) %}
  {% if fields.length > 0 %}
    {{ className }}({
    {% for field in fields %}
    required this.{{ field.name }},
    {% endfor %}
  });
  {% else %}
    {{ className }}();
  {% endif %}
{% endmacro %}

{# Recursive Borsh Reader, responsible for handling collections and any nested levels #}
{% macro borshReader(field) %}  
  {{ recursiveReader(field.nesting, field.baseType, field.isStruct) }}
{% endmacro %}

{% macro recursiveReader(depth, baseType, isStruct) %}
  {% if depth == 0 %}
    {% if isStruct %}
      {{ baseType }}Borsh.fromBorsh(reader)
    {% else %}
      {{ baseTypeReader(baseType) }}
    {% endif %}
  {% else %}
    reader.readArray(() {
      {% if isStruct %}
        // item is a struct, call fromBorsh per item
        return {{ baseType }}Borsh.fromBorsh(reader);
      {% else %}
        return {{ recursiveReader(depth - 1, baseType, false) }};
      {% endif %}
    })
  {% endif %}
{% endmacro %}

{# Reader for the base types (no nesting) #}
{% macro baseTypeReader(baseType, isStruct) %}
  {% if baseType == 'int' %}
    reader.readInt()
  {% elif baseType == 'BigInt' %}
    reader.readBigInt()
  {% elif baseType == 'String' %}
    reader.readString()
  {% elif baseType == 'Uint8List' %}
    reader.readFixedU8Array({{ field.size or 8}})
  {% elif baseType == 'Int8List' %}
    reader.readFixedI8Array({{ field.size or 8}})
  {% elif baseType == 'Uint16List' %}
    reader.readFixedU16Array({{ field.size or 16 }})
  {% elif baseType == 'Int16List' %}
    reader.readFixedI16Array({{ field.size or 16}})
  {% elif baseType == 'Uint32List' %}
    reader.readFixedU32Array({{ field.size or 32}})
  {% elif baseType == 'Int32List' %}
    reader.readFixedI32Array({{ field.size or 32}})
  {% elif baseType == 'Uint64List' %}
    reader.readFixedU64Array({{ field.size or 64}})
  {% elif baseType == 'Int64List' %}
    reader.readFixedI64Array({{ field.size or 64 }})
  {% elif baseType == 'bool' %}
    reader.readBool()
  {% elif baseType == 'Ed25519HDPublicKey' %}
    Ed25519HDPublicKey(Uint8List.fromList(reader.readFixedU8Array(32)))
  {% else %}
    reader.readUnknownType('{{ baseType }}')
  {% endif %}
{% endmacro %}

{# Recursive Borsh Writer, responsible to handle nested type of collections  #}
{% macro borshWriter(field, overrideFieldName="") %}
  {% set name = overrideFieldName if overrideFieldName else field.name %}
  {{ recursiveWriter(name, field.nesting, field.baseType, field.isStruct) }}
{% endmacro %}

{% macro recursiveWriter(varName, depth, baseType, isStruct) %}
  {% if depth == 0 %}
    {% if isStruct %}
      {{ varName }}.toBorsh(writer);
    {% else %}
    {# TODO: I have problem here because of these recursions i put ';' twice because twice is iterated here first trough writeArray and on the recursion i go inside here and i put ';' again #}
      {{ baseTypeWriter(baseType, varName) }};
    {% endif %}
  {% else %}
    writer.writeArray<{{ baseType }}>({{ varName }}, ({{ baseType }} item) {
      {% if isStruct %}
        // Each item is a struct
        item.toBorsh(writer);
      {% else %}
        {{ recursiveWriter("item", depth - 1, baseType, false) }};
      {% endif %}
    });
  {% endif %}
{% endmacro %}

{# Base Writer, no nested types inside #}
{% macro baseTypeWriter(baseType, varName, isStruct) %}
  {% if baseType == 'int' %}
    writer.writeInt({{ varName }})
  {% elif baseType == 'BigInt' %}
    writer.writeBigInt({{ varName }})
  {% elif baseType == 'String' %}
    writer.writeString({{ varName }})
  {% elif baseType == 'Uint8List' %}
    writer.writeFixedU8Array({{ varName }})
  {% elif baseType == 'Int8List' %}
    writer.writeFixedI8Array({{ varName }})
  {% elif baseType == 'Uint16List' %}
    writer.writeFixedU16Array({{ varName }})
  {% elif baseType == 'Int16List' %}
    writer.writeFixedI16Array({{ varName }})
  {% elif baseType == 'Uint32List' %}
    writer.writeFixedU32Array({{ varName }})
  {% elif baseType == 'Int32List' %}
    writer.writeFixedI32Array({{ varName }})
  {% elif baseType == 'Uint64List' %}
    writer.writeFixedU64Array({{ varName }})
  {% elif baseType == 'Int64List' %}
    writer.writeFixedI64Array({{ varName }})
  {% elif baseType == 'bool' %}
    writer.writeBool({{ varName }})
  {% elif baseType == 'Ed25519HDPublicKey' %}
    writer.writeFixedU8Array(Uint8List.fromList({{ varName }}.bytes))
  {% else %}
    writer.writeUnknownType('{{ baseType }}')
  {% endif %}
{% endmacro %}