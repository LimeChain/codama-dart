/// This code was AUTOGENERATED using the codama library.
/// Please DO NOT EDIT THIS FILE, instead use visitors
/// to add features, then rerun codama to update it.
///
/// https://github.com/codama-idl/codama
///

import 'dart:typed_data';
import 'package:solana/encoder.dart';
import 'package:solana/solana.dart';
import '../programs.dart';
import '../shared.dart';
import '../types/cpi_rule.dart';
import '../types/metadata_additional_field_rule.dart';
import '../types/transfer_amount_rule.dart';

const List<int> UPDATE_GUARD_DISCRIMINATOR = [
  51,
  38,
  175,
  180,
  25,
  249,
  39,
  24
];

/// Generated instruction class for UpdateGuard.
///

class UpdateGuardInstruction {
  // Accounts
  // The guard account.
  final Ed25519HDPublicKey guard;

  // The mint account.
  final Ed25519HDPublicKey mint;

  // The token_account account.
  final Ed25519HDPublicKey token_account;

  // The guard_authority account.
  final Ed25519HDPublicKey guard_authority;

  // The token_program account.
  final Ed25519HDPublicKey token_program;

  // The system_program account.
  final Ed25519HDPublicKey system_program;

  // Args
  final CpiRule? cpi_rule;
  final TransferAmountRule? transfer_amount_rule;
  final List<MetadataAdditionalFieldRule> additional_fields_rule;

  UpdateGuardInstruction({
    required this.guard,
    required this.mint,
    required this.token_account,
    required this.guard_authority,
    required this.token_program,
    required this.system_program,
    required this.cpi_rule,
    required this.transfer_amount_rule,
    required this.additional_fields_rule,
  });

  /// Builds the `Instruction` (data = discriminator + args).
  Instruction toInstruction({List<AccountMeta> remainingAccounts = const []}) {
    final keys = <AccountMeta>[
      AccountMeta(
        pubKey: guard,
        isSigner: false,
        isWriteable: true,
      ),
      AccountMeta(
        pubKey: mint,
        isSigner: false,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: token_account,
        isSigner: false,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: guard_authority,
        isSigner: true,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: token_program,
        isSigner: false,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: system_program,
        isSigner: false,
        isWriteable: false,
      ),
    ];

    if (remainingAccounts.isNotEmpty) {
      keys.addAll(remainingAccounts);
    }

    // Serialize: discriminator (8 bytes) + args
    final writer = BinaryWriter();
    writer.writeDiscriminator(Uint8List.fromList(UPDATE_GUARD_DISCRIMINATOR));
    writer.writeU8(cpi_rule != null ? 1 : 0);
    if (cpi_rule != null) {
      cpi_rule!.toBorsh(writer);
    }
    writer.writeU8(transfer_amount_rule != null ? 1 : 0);
    if (transfer_amount_rule != null) {
      transfer_amount_rule!.toBorsh(writer);
    }
    writer.writeArray<MetadataAdditionalFieldRule>(additional_fields_rule,
        (MetadataAdditionalFieldRule item) {
      // Each item is a struct
      item.toBorsh(writer);
    });

    return Instruction(
      programId: WenTransferGuardProgram.programId,
      accounts: keys,
      data: ByteArray(writer.toBytes()),
    );
  }
}
