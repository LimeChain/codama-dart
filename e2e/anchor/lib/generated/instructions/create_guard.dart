/// This code was AUTOGENERATED using the codama library.
/// Please DO NOT EDIT THIS FILE, instead use visitors
/// to add features, then rerun codama to update it.
///
/// https://github.com/codama-idl/codama
///

import 'dart:typed_data';
import 'package:solana/encoder.dart';
import 'package:solana/solana.dart';
import '../programs.dart';
import '../shared.dart';
import '../types/cpi_rule.dart';
import '../types/metadata_additional_field_rule.dart';
import '../types/transfer_amount_rule.dart';

const List<int> CREATE_GUARD_DISCRIMINATOR = [
  251,
  254,
  17,
  198,
  219,
  218,
  154,
  99
];

/// Generated instruction class for CreateGuard.
///

class CreateGuardInstruction {
  // Accounts
  // The guard account.
  final Ed25519HDPublicKey guard;

  // The mint account.
  final Ed25519HDPublicKey mint;

  // The mint_token_account account.
  final Ed25519HDPublicKey mint_token_account;

  // The guard_authority account.
  final Ed25519HDPublicKey guard_authority;

  // The payer account.
  final Ed25519HDPublicKey payer;

  // The associated_token_program account.
  final Ed25519HDPublicKey associated_token_program;

  // The token_program account.
  final Ed25519HDPublicKey token_program;

  // The system_program account.
  final Ed25519HDPublicKey system_program;

  // Args
  final String name;
  final String symbol;
  final String uri;
  final CpiRule? cpi_rule;
  final TransferAmountRule? transfer_amount_rule;
  final List<MetadataAdditionalFieldRule> additional_fields_rule;

  CreateGuardInstruction({
    required this.guard,
    required this.mint,
    required this.mint_token_account,
    required this.guard_authority,
    required this.payer,
    required this.associated_token_program,
    required this.token_program,
    required this.system_program,
    required this.name,
    required this.symbol,
    required this.uri,
    required this.cpi_rule,
    required this.transfer_amount_rule,
    required this.additional_fields_rule,
  });

  /// Builds the `Instruction` (data = discriminator + args).
  Instruction toInstruction({List<AccountMeta> remainingAccounts = const []}) {
    final keys = <AccountMeta>[
      AccountMeta(
        pubKey: guard,
        isSigner: false,
        isWriteable: true,
      ),
      AccountMeta(
        pubKey: mint,
        isSigner: true,
        isWriteable: true,
      ),
      AccountMeta(
        pubKey: mint_token_account,
        isSigner: false,
        isWriteable: true,
      ),
      AccountMeta(
        pubKey: guard_authority,
        isSigner: true,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: payer,
        isSigner: true,
        isWriteable: true,
      ),
      AccountMeta(
        pubKey: associated_token_program,
        isSigner: false,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: token_program,
        isSigner: false,
        isWriteable: false,
      ),
      AccountMeta(
        pubKey: system_program,
        isSigner: false,
        isWriteable: false,
      ),
    ];

    if (remainingAccounts.isNotEmpty) {
      keys.addAll(remainingAccounts);
    }

    // Serialize: discriminator (8 bytes) + args
    final writer = BinaryWriter();
    writer.writeDiscriminator(Uint8List.fromList(CREATE_GUARD_DISCRIMINATOR));
    writer.writeString(name);

    writer.writeString(symbol);

    writer.writeString(uri);

    writer.writeU8(cpi_rule != null ? 1 : 0);
    if (cpi_rule != null) {
      cpi_rule!.toBorsh(writer);
    }
    writer.writeU8(transfer_amount_rule != null ? 1 : 0);
    if (transfer_amount_rule != null) {
      transfer_amount_rule!.toBorsh(writer);
    }
    writer.writeArray<MetadataAdditionalFieldRule>(additional_fields_rule,
        (MetadataAdditionalFieldRule item) {
      // Each item is a struct
      item.toBorsh(writer);
    });

    return Instruction(
      programId: WenTransferGuardProgram.programId,
      accounts: keys,
      data: ByteArray(writer.toBytes()),
    );
  }
}
