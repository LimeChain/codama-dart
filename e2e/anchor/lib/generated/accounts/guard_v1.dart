/// This code was AUTOGENERATED using the codama library.
/// Please DO NOT EDIT THIS FILE, instead use visitors
/// to add features, then rerun codama to update it.
///
/// https://github.com/codama-idl/codama
///

import 'dart:typed_data';
import 'package:collection/collection.dart';
import 'package:solana/dto.dart';
import 'package:solana/solana.dart';
import '../shared.dart';
import '../types/cpi_rule.dart';
import '../types/metadata_additional_field_rule.dart';
import '../types/transfer_amount_rule.dart';

const List<int> GUARD_V1_DISCRIMINATOR = [185, 149, 156, 78, 245, 108, 172, 68];

/// Generated account class for GuardV1.
///
class GuardV1 {
  // Fields
  final Ed25519HDPublicKey mint;
  final int /* type: u8 */ bump;
  final CpiRule? cpi_rule;
  final TransferAmountRule? transfer_amount_rule;
  final List<MetadataAdditionalFieldRule> additional_fields_rule;

  // Constructor
  GuardV1({
    required this.mint,
    required this.bump,
    required this.cpi_rule,
    required this.transfer_amount_rule,
    required this.additional_fields_rule,
  });

  /// Deserializes this account from borsh.
  static GuardV1 fromBorsh(BinaryReader reader) {
    return GuardV1(
      mint: Ed25519HDPublicKey(reader.readPubkey()),
      bump: reader.readU8(),
      cpi_rule: reader.readU8() == 1 ? CpiRuleBorsh.fromBorsh(reader) : null,
      transfer_amount_rule: reader.readU8() == 1
          ? TransferAmountRuleBorsh.fromBorsh(reader)
          : null,
      additional_fields_rule: reader.readArray(() {
        // item is a struct, call fromBorsh per item
        return MetadataAdditionalFieldRuleBorsh.fromBorsh(reader);
      }),
    );
  }

  /// Serializes this account to borsh.
  void toBorsh(BinaryWriter writer) {
    writer.writePubkey(Uint8List.fromList(mint.bytes));

    writer.writeU8(bump);

    writer.writeU8(cpi_rule != null ? 1 : 0);
    if (cpi_rule != null) {
      cpi_rule!.toBorsh(writer);
    }
    writer.writeU8(transfer_amount_rule != null ? 1 : 0);
    if (transfer_amount_rule != null) {
      transfer_amount_rule!.toBorsh(writer);
    }
    writer.writeArray<MetadataAdditionalFieldRule>(additional_fields_rule,
        (MetadataAdditionalFieldRule item) {
      // Each item is a struct
      item.toBorsh(writer);
    });
  }

  /// Creates a [GuardV1] from its bytes representation.
  static GuardV1 fromBytes(Uint8List data) {
    final buffer = ByteData.view(data.buffer);
    final reader = BinaryReader(buffer);

    // Validate the discriminator
    final discriminator = reader.readDiscriminator();
    if (!const ListEquality().equals(discriminator, GUARD_V1_DISCRIMINATOR)) {
      throw FormatException('Invalid account discriminator');
    }

    return GuardV1.fromBorsh(reader);
  }

  /// Serializes this account to its bytes representation.
  Uint8List toBytes() {
    final writer = BinaryWriter();

    // Write discriminator
    writer.writeDiscriminator(Uint8List.fromList(GUARD_V1_DISCRIMINATOR));

    // Write account data
    toBorsh(writer);

    return writer.toBytes();
  }

  /// Fetches a [GuardV1] from the blockchain.
  static Future<GuardV1> fetch(
    RpcClient client,
    Ed25519HDPublicKey address,
  ) async {
    final accountInfo = await client.getAccountInfo(address.toBase58(),
        encoding: Encoding.base64);
    final data = accountInfo.value?.data;

    if (data == null) {
      throw AccountNotFoundError(address);
    }

    if (data is! BinaryAccountData) {
      throw FormatException(
          'Expected binary account data, got ${data.runtimeType}');
    }

    return fromBytes(Uint8List.fromList(data.data));
  }

  /// Fetches a [GuardV1] from the blockchain if it exists.
  static Future<GuardV1?> fetchNullable(
    RpcClient client,
    Ed25519HDPublicKey address,
  ) async {
    try {
      return await fetch(client, address);
    } catch (e) {
      if (e is AccountNotFoundError) {
        return null;
      }
      rethrow;
    }
  }
}
